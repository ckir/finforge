// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
// These attributes are typically found at the crate root or module level
// and cause compilation errors when included within another module.
// They have been commented out to resolve the "an inner attribute is not permitted in this context" errors.
/*
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `yahoo.proto`
*/

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(serde::Serialize, serde::Deserialize)]
#[derive(PartialEq,Clone,Default)]
pub struct PricingData {
    // message fields
    pub id: ::std::string::String,
    pub price: f32,
    pub time: i64,
    pub currency: ::std::string::String,
    pub exchange: ::std::string::String,
    pub quoteType: i32,
    pub marketHours: i32,
    pub changePercent: f32,
    pub dayVolume: i64,
    pub dayHigh: f32,
    pub dayLow: f32,
    pub change: f32,
    pub shortName: ::std::string::String,
    pub expireDate: i64,
    pub openPrice: f32,
    pub previousClose: f32,
    pub strikePrice: f32,
    pub underlyingSymbol: ::std::string::String,
    pub openInterest: i64,
    pub optionsType: i32,
    pub miniOption: i64,
    pub lastSize: i64,
    pub bid: f32,
    pub bidSize: f32,
    pub ask: f32,
    pub askSize: f32,
    pub priceHint: i64,
    pub vol_24hr: bool,
    pub volAllCurrencies: bool,
    pub fromcurrency: ::std::string::String,
    pub lastMarket: ::std::string::String,
    pub circulatingSupply: f64,
    pub marketcap: f64,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PricingData {
    fn default() -> &'a PricingData {
        <PricingData as ::protobuf::Message>::default_instance()
    }
}

impl PricingData {
    pub fn new() -> PricingData {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // float price = 2;


    pub fn get_price(&self) -> f32 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0.;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: f32) {
        self.price = v;
    }

    // int64 time = 3;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // string currency = 4;


    pub fn get_currency(&self) -> &str {
        &self.currency
    }
    pub fn clear_currency(&mut self) {
        self.currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        &mut self.currency
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currency, ::std::string::String::new())
    }

    // string exchange = 5;


    pub fn get_exchange(&self) -> &str {
        &self.exchange
    }
    pub fn clear_exchange(&mut self) {
        self.exchange.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: ::std::string::String) {
        self.exchange = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exchange(&mut self) -> &mut ::std::string::String {
        &mut self.exchange
    }

    // Take field
    pub fn take_exchange(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exchange, ::std::string::String::new())
    }

    // int32 quoteType = 6;


    pub fn get_quoteType(&self) -> i32 {
        self.quoteType
    }
    pub fn clear_quoteType(&mut self) {
        self.quoteType = 0;
    }

    // Param is passed by value, moved
    pub fn set_quoteType(&mut self, v: i32) {
        self.quoteType = v;
    }

    // int32 marketHours = 7;


    pub fn get_marketHours(&self) -> i32 {
        self.marketHours
    }
    pub fn clear_marketHours(&mut self) {
        self.marketHours = 0;
    }

    // Param is passed by value, moved
    pub fn set_marketHours(&mut self, v: i32) {
        self.marketHours = v;
    }

    // float changePercent = 8;


    pub fn get_changePercent(&self) -> f32 {
        self.changePercent
    }
    pub fn clear_changePercent(&mut self) {
        self.changePercent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_changePercent(&mut self, v: f32) {
        self.changePercent = v;
    }

    // int64 dayVolume = 9;


    pub fn get_dayVolume(&self) -> i64 {
        self.dayVolume
    }
    pub fn clear_dayVolume(&mut self) {
        self.dayVolume = 0;
    }

    // Param is passed by value, moved
    pub fn set_dayVolume(&mut self, v: i64) {
        self.dayVolume = v;
    }

    // float dayHigh = 10;


    pub fn get_dayHigh(&self) -> f32 {
        self.dayHigh
    }
    pub fn clear_dayHigh(&mut self) {
        self.dayHigh = 0.;
    }

    // Param is passed by value, moved
    pub fn set_dayHigh(&mut self, v: f32) {
        self.dayHigh = v;
    }

    // float dayLow = 11;


    pub fn get_dayLow(&self) -> f32 {
        self.dayLow
    }
    pub fn clear_dayLow(&mut self) {
        self.dayLow = 0.;
    }

    // Param is passed by value, moved
    pub fn set_dayLow(&mut self, v: f32) {
        self.dayLow = v;
    }

    // float change = 12;


    pub fn get_change(&self) -> f32 {
        self.change
    }
    pub fn clear_change(&mut self) {
        self.change = 0.;
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: f32) {
        self.change = v;
    }

    // string shortName = 13;


    pub fn get_shortName(&self) -> &str {
        &self.shortName
    }
    pub fn clear_shortName(&mut self) {
        self.shortName.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortName(&mut self, v: ::std::string::String) {
        self.shortName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortName(&mut self) -> &mut ::std::string::String {
        &mut self.shortName
    }

    // Take field
    pub fn take_shortName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shortName, ::std::string::String::new())
    }

    // int64 expireDate = 14;


    pub fn get_expireDate(&self) -> i64 {
        self.expireDate
    }
    pub fn clear_expireDate(&mut self) {
        self.expireDate = 0;
    }

    // Param is passed by value, moved
    pub fn set_expireDate(&mut self, v: i64) {
        self.expireDate = v;
    }

    // float openPrice = 15;


    pub fn get_openPrice(&self) -> f32 {
        self.openPrice
    }
    pub fn clear_openPrice(&mut self) {
        self.openPrice = 0.;
    }

    // Param is passed by value, moved
    pub fn set_openPrice(&mut self, v: f32) {
        self.openPrice = v;
    }

    // float previousClose = 16;


    pub fn get_previousClose(&self) -> f32 {
        self.previousClose
    }
    pub fn clear_previousClose(&mut self) {
        self.previousClose = 0.;
    }

    // Param is passed by value, moved
    pub fn set_previousClose(&mut self, v: f32) {
        self.previousClose = v;
    }

    // float strikePrice = 17;


    pub fn get_strikePrice(&self) -> f32 {
        self.strikePrice
    }
    pub fn clear_strikePrice(&mut self) {
        self.strikePrice = 0.;
    }

    // Param is passed by value, moved
    pub fn set_strikePrice(&mut self, v: f32) {
        self.strikePrice = v;
    }

    // string underlyingSymbol = 18;


    pub fn get_underlyingSymbol(&self) -> &str {
        &self.underlyingSymbol
    }
    pub fn clear_underlyingSymbol(&mut self) {
        self.underlyingSymbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_underlyingSymbol(&mut self, v: ::std::string::String) {
        self.underlyingSymbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_underlyingSymbol(&mut self) -> &mut ::std::string::String {
        &mut self.underlyingSymbol
    }

    // Take field
    pub fn take_underlyingSymbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.underlyingSymbol, ::std::string::String::new())
    }

    // int64 openInterest = 19;


    pub fn get_openInterest(&self) -> i64 {
        self.openInterest
    }
    pub fn clear_openInterest(&mut self) {
        self.openInterest = 0;
    }

    // Param is passed by value, moved
    pub fn set_openInterest(&mut self, v: i64) {
        self.openInterest = v;
    }

    // int32 optionsType = 20;


    pub fn get_optionsType(&self) -> i32 {
        self.optionsType
    }
    pub fn clear_optionsType(&mut self) {
        self.optionsType = 0;
    }

    // Param is passed by value, moved
    pub fn set_optionsType(&mut self, v: i32) {
        self.optionsType = v;
    }

    // int64 miniOption = 21;


    pub fn get_miniOption(&self) -> i64 {
        self.miniOption
    }
    pub fn clear_miniOption(&mut self) {
        self.miniOption = 0;
    }

    // Param is passed by value, moved
    pub fn set_miniOption(&mut self, v: i64) {
        self.miniOption = v;
    }

    // int64 lastSize = 22;


    pub fn get_lastSize(&self) -> i64 {
        self.lastSize
    }
    pub fn clear_lastSize(&mut self) {
        self.lastSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastSize(&mut self, v: i64) {
        self.lastSize = v;
    }

    // float bid = 23;


    pub fn get_bid(&self) -> f32 {
        self.bid
    }
    pub fn clear_bid(&mut self) {
        self.bid = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bid(&mut self, v: f32) {
        self.bid = v;
    }

    // float bidSize = 24;


    pub fn get_bidSize(&self) -> f32 {
        self.bidSize
    }
    pub fn clear_bidSize(&mut self) {
        self.bidSize = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bidSize(&mut self, v: f32) {
        self.bidSize = v;
    }

    // float ask = 25;


    pub fn get_ask(&self) -> f32 {
        self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: f32) {
        self.ask = v;
    }

    // float askSize = 26;


    pub fn get_askSize(&self) -> f32 {
        self.askSize
    }
    pub fn clear_askSize(&mut self) {
        self.askSize = 0.;
    }

    // Param is passed by value, moved
    pub fn set_askSize(&mut self, v: f32) {
        self.askSize = v;
    }

    // int64 priceHint = 27;


    pub fn get_priceHint(&self) -> i64 {
        self.priceHint
    }
    pub fn clear_priceHint(&mut self) {
        self.priceHint = 0;
    }

    // Param is passed by value, moved
    pub fn set_priceHint(&mut self, v: i64) {
        self.priceHint = v;
    }

    // bool vol_24hr = 28;


    pub fn get_vol_24hr(&self) -> bool {
        self.vol_24hr
    }
    pub fn clear_vol_24hr(&mut self) {
        self.vol_24hr = false;
    }

    // Param is passed by value, moved
    pub fn set_vol_24hr(&mut self, v: bool) {
        self.vol_24hr = v;
    }

    // bool volAllCurrencies = 29;


    pub fn get_volAllCurrencies(&self) -> bool {
        self.volAllCurrencies
    }
    pub fn clear_volAllCurrencies(&mut self) {
        self.volAllCurrencies = false;
    }

    // Param is passed by value, moved
    pub fn set_volAllCurrencies(&mut self, v: bool) {
        self.volAllCurrencies = v;
    }

    // string fromcurrency = 30;


    pub fn get_fromcurrency(&self) -> &str {
        &self.fromcurrency
    }
    pub fn clear_fromcurrency(&mut self) {
        self.fromcurrency.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromcurrency(&mut self, v: ::std::string::String) {
        self.fromcurrency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromcurrency(&mut self) -> &mut ::std::string::String {
        &mut self.fromcurrency
    }

    // Take field
    pub fn take_fromcurrency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fromcurrency, ::std::string::String::new())
    }

    // string lastMarket = 31;


    pub fn get_lastMarket(&self) -> &str {
        &self.lastMarket
    }
    pub fn clear_lastMarket(&mut self) {
        self.lastMarket.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastMarket(&mut self, v: ::std::string::String) {
        self.lastMarket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastMarket(&mut self) -> &mut ::std::string::String {
        &mut self.lastMarket
    }

    // Take field
    pub fn take_lastMarket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastMarket, ::std::string::String::new())
    }

    // double circulatingSupply = 32;


    pub fn get_circulatingSupply(&self) -> f64 {
        self.circulatingSupply
    }
    pub fn clear_circulatingSupply(&mut self) {
        self.circulatingSupply = 0.;
    }

    // Param is passed by value, moved
    pub fn set_circulatingSupply(&mut self, v: f64) {
        self.circulatingSupply = v;
    }

    // double marketcap = 33;


    pub fn get_marketcap(&self) -> f64 {
        self.marketcap
    }
    pub fn clear_marketcap(&mut self) {
        self.marketcap = 0.;
    }

    // Param is passed by value, moved
    pub fn set_marketcap(&mut self, v: f64) {
        self.marketcap = v;
    }
}

impl ::protobuf::Message for PricingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.price = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.currency)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exchange)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quoteType = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.marketHours = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.changePercent = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dayVolume = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dayHigh = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dayLow = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.change = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shortName)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expireDate = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.openPrice = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.previousClose = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.strikePrice = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.underlyingSymbol)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.openInterest = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.optionsType = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.miniOption = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastSize = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bid = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bidSize = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ask = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.askSize = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.priceHint = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vol_24hr = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.volAllCurrencies = tmp;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fromcurrency)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastMarket)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.circulatingSupply = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.marketcap = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.price != 0. {
            my_size += 5;
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.currency);
        }
        if !self.exchange.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.exchange);
        }
        if self.quoteType != 0 {
            my_size += ::protobuf::rt::value_size(6, self.quoteType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.marketHours != 0 {
            my_size += ::protobuf::rt::value_size(7, self.marketHours, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.changePercent != 0. {
            my_size += 5;
        }
        if self.dayVolume != 0 {
            my_size += ::protobuf::rt::value_size(9, self.dayVolume, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dayHigh != 0. {
            my_size += 5;
        }
        if self.dayLow != 0. {
            my_size += 5;
        }
        if self.change != 0. {
            my_size += 5;
        }
        if !self.shortName.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.shortName);
        }
        if self.expireDate != 0 {
            my_size += ::protobuf::rt::value_size(14, self.expireDate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.openPrice != 0. {
            my_size += 5;
        }
        if self.previousClose != 0. {
            my_size += 6;
        }
        if self.strikePrice != 0. {
            my_size += 6;
        }
        if !self.underlyingSymbol.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.underlyingSymbol);
        }
        if self.openInterest != 0 {
            my_size += ::protobuf::rt::value_size(19, self.openInterest, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.optionsType != 0 {
            my_size += ::protobuf::rt::value_size(20, self.optionsType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.miniOption != 0 {
            my_size += ::protobuf::rt::value_size(21, self.miniOption, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastSize != 0 {
            my_size += ::protobuf::rt::value_size(22, self.lastSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bid != 0. {
            my_size += 6;
        }
        if self.bidSize != 0. {
            my_size += 6;
        }
        if self.ask != 0. {
            my_size += 6;
        }
        if self.askSize != 0. {
            my_size += 6;
        }
        if self.priceHint != 0 {
            my_size += ::protobuf::rt::value_size(27, self.priceHint, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vol_24hr != false {
            my_size += 3;
        }
        if self.volAllCurrencies != false {
            my_size += 3;
        }
        if !self.fromcurrency.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.fromcurrency);
        }
        if !self.lastMarket.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.lastMarket);
        }
        if self.circulatingSupply != 0. {
            my_size += 10;
        }
        if self.marketcap != 0. {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.price != 0. {
            os.write_float(2, self.price)?;
        }
        if self.time != 0 {
            os.write_int64(3, self.time)?;
        }
        if !self.currency.is_empty() {
            os.write_string(4, &self.currency)?;
        }
        if !self.exchange.is_empty() {
            os.write_string(5, &self.exchange)?;
        }
        if self.quoteType != 0 {
            os.write_int32(6, self.quoteType)?;
        }
        if self.marketHours != 0 {
            os.write_int32(7, self.marketHours)?;
        }
        if self.changePercent != 0. {
            os.write_float(8, self.changePercent)?;
        }
        if self.dayVolume != 0 {
            os.write_int64(9, self.dayVolume)?;
        }
        if self.dayHigh != 0. {
            os.write_float(10, self.dayHigh)?;
        }
        if self.dayLow != 0. {
            os.write_float(11, self.dayLow)?;
        }
        if self.change != 0. {
            os.write_float(12, self.change)?;
        }
        if !self.shortName.is_empty() {
            os.write_string(13, &self.shortName)?;
        }
        if self.expireDate != 0 {
            os.write_int64(14, self.expireDate)?;
        }
        if self.openPrice != 0. {
            os.write_float(15, self.openPrice)?;
        }
        if self.previousClose != 0. {
            os.write_float(16, self.previousClose)?;
        }
        if self.strikePrice != 0. {
            os.write_float(17, self.strikePrice)?;
        }
        if !self.underlyingSymbol.is_empty() {
            os.write_string(18, &self.underlyingSymbol)?;
        }
        if self.openInterest != 0 {
            os.write_int64(19, self.openInterest)?;
        }
        if self.optionsType != 0 {
            os.write_int32(20, self.optionsType)?;
        }
        if self.miniOption != 0 {
            os.write_int64(21, self.miniOption)?;
        }
        if self.lastSize != 0 {
            os.write_int64(22, self.lastSize)?;
        }
        if self.bid != 0. {
            os.write_float(23, self.bid)?;
        }
        if self.bidSize != 0. {
            os.write_float(24, self.bidSize)?;
        }
        if self.ask != 0. {
            os.write_float(25, self.ask)?;
        }
        if self.askSize != 0. {
            os.write_float(26, self.askSize)?;
        }
        if self.priceHint != 0 {
            os.write_int64(27, self.priceHint)?;
        }
        if self.vol_24hr != false {
            os.write_bool(28, self.vol_24hr)?;
        }
        if self.volAllCurrencies != false {
            os.write_bool(29, self.volAllCurrencies)?;
        }
        if !self.fromcurrency.is_empty() {
            os.write_string(30, &self.fromcurrency)?;
        }
        if !self.lastMarket.is_empty() {
            os.write_string(31, &self.lastMarket)?;
        }
        if self.circulatingSupply != 0. {
            os.write_double(32, self.circulatingSupply)?;
        }
        if self.marketcap != 0. {
            os.write_double(33, self.marketcap)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn ::std::any::Any {
        self as &dyn ::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut dyn ::std::any::Any {
        self as &mut dyn ::std::any::Any
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn ::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PricingData {
        PricingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PricingData| { &m.id },
                |m: &mut PricingData| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "price",
                |m: &PricingData| { &m.price },
                |m: &mut PricingData| { &mut m.price },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "time",
                |m: &PricingData| { &m.time },
                |m: &mut PricingData| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currency",
                |m: &PricingData| { &m.currency },
                |m: &mut PricingData| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exchange",
                |m: &PricingData| { &m.exchange },
                |m: &mut PricingData| { &mut m.exchange },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quoteType",
                |m: &PricingData| { &m.quoteType },
                |m: &mut PricingData| { &mut m.quoteType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "marketHours",
                |m: &PricingData| { &m.marketHours },
                |m: &mut PricingData| { &mut m.marketHours },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "changePercent",
                |m: &PricingData| { &m.changePercent },
                |m: &mut PricingData| { &mut m.changePercent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dayVolume",
                |m: &PricingData| { &m.dayVolume },
                |m: &mut PricingData| { &mut m.dayVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "dayHigh",
                |m: &PricingData| { &m.dayHigh },
                |m: &mut PricingData| { &mut m.dayHigh },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "dayLow",
                |m: &PricingData| { &m.dayLow },
                |m: &mut PricingData| { &mut m.dayLow },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "change",
                |m: &PricingData| { &m.change },
                |m: &mut PricingData| { &mut m.change },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shortName",
                |m: &PricingData| { &m.shortName },
                |m: &mut PricingData| { &mut m.shortName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expireDate",
                |m: &PricingData| { &m.expireDate },
                |m: &mut PricingData| { &mut m.expireDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "openPrice",
                |m: &PricingData| { &m.openPrice },
                |m: &mut PricingData| { &mut m.openPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "previousClose",
                |m: &PricingData| { &m.previousClose },
                |m: &mut PricingData| { &mut m.previousClose },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "strikePrice",
                |m: &PricingData| { &m.strikePrice },
                |m: &mut PricingData| { &mut m.strikePrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "underlyingSymbol",
                |m: &PricingData| { &m.underlyingSymbol },
                |m: &mut PricingData| { &mut m.underlyingSymbol },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "openInterest",
                |m: &PricingData| { &m.openInterest },
                |m: &mut PricingData| { &mut m.openInterest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "optionsType",
                |m: &PricingData| { &m.optionsType },
                |m: &mut PricingData| { &mut m.optionsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "miniOption",
                |m: &PricingData| { &m.miniOption },
                |m: &mut PricingData| { &mut m.miniOption },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastSize",
                |m: &PricingData| { &m.lastSize },
                |m: &mut PricingData| { &mut m.lastSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bid",
                |m: &PricingData| { &m.bid },
                |m: &mut PricingData| { &mut m.bid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bidSize",
                |m: &PricingData| { &m.bidSize },
                |m: &mut PricingData| { &mut m.bidSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ask",
                |m: &PricingData| { &m.ask },
                |m: &mut PricingData| { &mut m.ask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "askSize",
                |m: &PricingData| { &m.askSize },
                |m: &mut PricingData| { &mut m.askSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "priceHint",
                |m: &PricingData| { &m.priceHint },
                |m: &mut PricingData| { &mut m.priceHint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vol_24hr",
                |m: &PricingData| { &m.vol_24hr },
                |m: &mut PricingData| { &mut m.vol_24hr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "volAllCurrencies",
                |m: &PricingData| { &m.volAllCurrencies },
                |m: &mut PricingData| { &mut m.volAllCurrencies },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromcurrency",
                |m: &PricingData| { &m.fromcurrency },
                |m: &mut PricingData| { &mut m.fromcurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastMarket",
                |m: &PricingData| { &m.lastMarket },
                |m: &mut PricingData| { &mut m.lastMarket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "circulatingSupply",
                |m: &PricingData| { &m.circulatingSupply },
                |m: &mut PricingData| { &mut m.circulatingSupply },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "marketcap",
                |m: &PricingData| { &m.marketcap },
                |m: &mut PricingData| { &mut m.marketcap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PricingData>(
                "PricingData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PricingData {
        static instance: ::protobuf::rt::LazyV2<PricingData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PricingData::new)
    }
}

impl ::protobuf::Clear for PricingData {
    fn clear(&mut self) {
        self.id.clear();
        self.price = 0.;
        self.time = 0;
        self.currency.clear();
        self.exchange.clear();
        self.quoteType = 0;
        self.marketHours = 0;
        self.changePercent = 0.;
        self.dayVolume = 0;
        self.dayHigh = 0.;
        self.dayLow = 0.;
        self.change = 0.;
        self.shortName.clear();
        self.expireDate = 0;
        self.openPrice = 0.;
        self.previousClose = 0.;
        self.strikePrice = 0.;
        self.underlyingSymbol.clear();
        self.openInterest = 0;
        self.optionsType = 0;
        self.miniOption = 0;
        self.lastSize = 0;
        self.bid = 0.;
        self.bidSize = 0.;
        self.ask = 0.;
        self.askSize = 0.;
        self.priceHint = 0;
        self.vol_24hr = false;
        self.volAllCurrencies = false;
        self.fromcurrency.clear();
        self.lastMarket.clear();
        self.circulatingSupply = 0.;
        self.marketcap = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PricingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PricingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0byahoo.proto\x12\ryahoo_finance\"\xb0\x08\n\x0bPricingData\x12\x10\
    \n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\x16\n\x05price\x18\x02\x20\x01\
    (\x02R\x05priceB\0\x12\x14\n\x04time\x18\x03\x20\x01(\x03R\x04timeB\0\
    \x12\x1c\n\x08currency\x18\x04\x20\x01(\tR\x08currencyB\0\x12\x1c\n\x08e\
    xchange\x18\x05\x20\x01(\tR\x08exchangeB\0\x12\x1e\n\tquoteType\x18\x06\
    \x20\x01(\x05R\tquoteTypeB\0\x12\"\n\x0bmarketHours\x18\x07\x20\x01(\x05\
    R\x0bmarketHoursB\0\x12&\n\rchangePercent\x18\x08\x20\x01(\x02R\rchangeP\
    ercentB\0\x12\x1e\n\tdayVolume\x18\t\x20\x01(\x03R\tdayVolumeB\0\x12\x1a\
    \n\x07dayHigh\x18\n\x20\x01(\x02R\x07dayHighB\0\x12\x18\n\x06dayLow\x18\
    \x0b\x20\x01(\x02R\x06dayLowB\0\x12\x18\n\x06change\x18\x0c\x20\x01(\x02\
    R\x06changeB\0\x12\x1e\n\tshortName\x18\r\x20\x01(\tR\tshortNameB\0\x12\
    \x20\n\nexpireDate\x18\x0e\x20\x01(\x03R\nexpireDateB\0\x12\x1e\n\topenP\
    rice\x18\x0f\x20\x01(\x02R\topenPriceB\0\x12&\n\rpreviousClose\x18\x10\
    \x20\x01(\x02R\rpreviousCloseB\0\x12\"\n\x0bstrikePrice\x18\x11\x20\x01(\
    \x02R\x0bstrikePriceB\0\x12,\n\x10underlyingSymbol\x18\x12\x20\x01(\tR\
    \x10underlyingSymbolB\0\x12$\n\x0copenInterest\x18\x13\x20\x01(\x03R\x0c\
    openInterestB\0\x12\"\n\x0boptionsType\x18\x14\x20\x01(\x05R\x0boptionsT\
    ypeB\0\x12\x20\n\nminiOption\x18\x15\x20\x01(\x03R\nminiOptionB\0\x12\
    \x1c\n\x08lastSize\x18\x16\x20\x01(\x03R\x08lastSizeB\0\x12\x12\n\x03bid\
    \x18\x17\x20\x01(\x02R\x03bidB\0\x12\x1a\n\x07bidSize\x18\x18\x20\x01(\
    \x02R\x07bidSizeB\0\x12\x12\n\x03ask\x18\x19\x20\x01(\x02R\x03askB\0\x12\
    \x1a\n\x07askSize\x18\x1a\x20\x01(\x02R\x07askSizeB\0\x12\x1e\n\tpriceHi\
    nt\x18\x1b\x20\x01(\x03R\tpriceHintB\0\x12\x1b\n\x08vol_24hr\x18\x1c\x20\
    \x01(\x08R\x07vol24hrB\0\x12,\n\x10volAllCurrencies\x18\x1d\x20\x01(\x08\
    R\x10volAllCurrenciesB\0\x12$\n\x0cfromcurrency\x18\x1e\x20\x01(\tR\x0cf\
    romcurrencyB\0\x12\x20\n\nlastMarket\x18\x1f\x20\x01(\tR\nlastMarketB\0\
    \x12.\n\x11circulatingSupply\x18\x20\x20\x01(\x01R\x11circulatingSupplyB\
    \0\x12\x1e\n\tmarketcap\x18!\x20\x01(\x01R\tmarketcapB\0:\0B\0b\x06proto\
    3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
